package repository

import (
	"context"
	"time"

	"github.com/wnmay/horo/services/chat-service/internal/domain"
	outbound_port "github.com/wnmay/horo/services/chat-service/internal/ports/outbound"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type mongoRoomRepository struct {
	collection *mongo.Collection
}

func NewMongoRoomRepository(db *mongo.Database, collectionName string) outbound_port.RoomRepositoryPort {
	collection := db.Collection(collectionName)

	return &mongoRoomRepository{
		collection: collection,
	}
}

func (r *mongoRoomRepository) FindRoomByID(ctx context.Context, roomID string) (*domain.Room, error) {
	objID, err := primitive.ObjectIDFromHex(roomID)
	if err != nil {
		return nil, err // invalid ObjectID string
	}

	filter := bson.M{"_id": objID}

	var room domain.Room
	if err := r.collection.FindOne(ctx, filter).Decode(&room); err != nil {
		return nil, err
	}
	return &room, nil
}

func (r *mongoRoomRepository) CreateRoom(ctx context.Context, room *domain.Room) (string, error) {
	model := RoomModel{
		//ID auto-generated by Mongo
		ProphetID:  room.ProphetID,
		CustomerID: room.CustomerID,
		CourseID:   room.CourseID,
		CreatedAt:  time.Now(),
	}
	res, err := r.collection.InsertOne(ctx, model)
	if err != nil {
		return "", err
	}

	roomIDStr := res.InsertedID.(primitive.ObjectID).Hex()
	return roomIDStr, nil
}

func (r *mongoRoomRepository) GetChatRoomsByCustomerID(ctx context.Context, customerID string) ([]*domain.Room, error) {
	filter := bson.M{"customer_id": customerID}
	cursor, err := r.collection.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	var rooms []*RoomModel
	if err := cursor.All(ctx, &rooms); err != nil {
		return nil, err
	}
	var domainRooms []*domain.Room
	for _, rm := range rooms {
		domainRooms = append(domainRooms, rm.ToDomain())
	}
	return domainRooms, nil
}

func (r *mongoRoomRepository) GetChatRoomsByProphetID(ctx context.Context, prophetID string) ([]*domain.Room, error) {
	filter := bson.M{"prophet_id": prophetID}
	cursor, err := r.collection.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)
	var rooms []*RoomModel

	if err := cursor.All(ctx, &rooms); err != nil {
		return nil, err
	}
	var domainRooms []*domain.Room
	for _, rm := range rooms {
		domainRooms = append(domainRooms, rm.ToDomain())
	}
	return domainRooms, nil
}
